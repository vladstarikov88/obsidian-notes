#### Принцип открытости-закрытости

Модуль должен быть открыт для расширения и закрыт для изменения.
Модуль должен быть реализован таким образом, чтобы добавление новой сущности не приводило к изменениям.

По Бертрану-Мейеру считается, что функционал можно расширить с помощью наследования. 

--------
Код ниже нарушает принцип OCP, так как при добавлении новой фигуры (класса этой фигуры) придется обновить метод  `sum` класса `AreaCalculator`, что только усложнит поддержку системы
```
class Shape { ... }
class Circle { ... }

class AreaCalculator {
  constructor()
  ...

  sum() {
    if (shape.type === 'circle') { ... }
    if (shape.type === 'square') { ... }
  }
}
```
<div style="text-align:center; color: #aa0000">Плохой пример</div>

------------
Код ниже НЕ нарушает данный принцип, так как при добавлении новой фигуры не потребуется изменять метод `sum`, так как класс этой фигуры уже будет содержать необходимый метод `area`
```
class Shape { ..., area() }
class Circle { ..., area() }

class AreaCalculator {
  constructor(shapes) {
    this.shapes = shapes
  }
  ...

  sum() {
    return this.shapes.reduce((acc, el) => acc += shape.area(), 0)
  }
}
```
<div style="text-align:center; color: #00aa00">Хороший пример</div>


------------
*Изменяя уже написанный модуль, который прошел все тесты и успешно работает на проде, мы приближаем появление конфликтных ситуаций, где второй программист, использующий модуль, будет в недоумении, что модуль работает не так, как ожидается. То есть не так, как он работал раньше.

Согласно этому принципу можно лишь фиксить баги*